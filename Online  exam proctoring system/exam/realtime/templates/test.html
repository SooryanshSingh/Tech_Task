{% load static %}
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ exam.title }}</title>
    <link rel="stylesheet" type="text/css" href="{% static 'test.css' %}">
    <style>
       

        .chat-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            padding: 10px;
            display: none;
            z-index: 1000;
            max-width: 300px; 
        }

        .chat-container.active {
            display: block;
        }

        .chat-log {
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>{{ exam.title }}</h1>
    <p>{{ exam.description }}</p>

    <div class="timer-container">
        <strong>Time Remaining:</strong>
        <span id="timer"></span>
    </div>

  
    <form id="exam-form" method="post" action="{% url 'test_with_chat' exam.id %}">
        {% csrf_token %}
        <div class="container">
            <div class="question-nav">
                <h3>Questions</h3>
                <ul>
                    {% for question in questions %}
                        <li><a href="#" class="question-link" data-question-id="question_{{ question.id }}">Question {{ forloop.counter }}</a></li>
                    {% endfor %}
                </ul>
            </div>
            <div class="questions">
                {% for question in questions %}
                    <div id="question_{{ question.id }}" class="question-item{% if forloop.first %} active{% endif %}">
                        <h2>Question {{ forloop.counter }}:</h2>
                        <p>{{ question.text }}</p>
                        <ul>
                            {% for answer in question.answers.all %}
                                <li>
                                    <label>
                                        <input type="radio" name="answer_{{ question.id }}" value="{{ answer.id }}">
                                        {{ answer.text }}
                                    </label>
                                </li>
                            {% endfor %}
                        </ul>
                    </div>
                {% endfor %}
                <div>
                    <button type="button" id="prev-button" disabled>Previous</button>
                    <button type="button" id="next-button">Next</button>
                    <button type="button" id="clear-button">Clear Response</button>
                </div>
                <input type="submit" value="Submit Answers" class="submit-button" disabled>
            </div>
            <button type="button" class="chat-toggle-button" id="chat-toggle-button">Chat with Proctor</button>
            <div class="chat-container" id="chat-container">
                <button type="button" class="chat-close-button" id="chat-close-button">Close Chat</button>
                <h2>Chat with Proctor</h2>
                <div class="chat-log" id="chat-log"></div>
                <input id="chat-message-input" type="text" name="chat_message" placeholder="Type your message...">
                <button id="chat-message-submit">Send</button>
            </div>
        </div>
    </form>

    {% if is_proctor %}
        <div class="close">
            <button type="button" id="close-exam-button" class="centered-button">Close Exam</button>
        </div>
    {% endif %}
    {% if is_proctor %}

    <div class="main-grid-container">
        <div class="video-container">
        <div><video id="student-video" autoplay playsinline></video>   
        </div>
        </div>
    {% endif %}

    <script>
        const roomName = "{{ room_name }}";
        const username = "{{ user.username }}";
        const chatSocket = new WebSocket(
            'ws://' + window.location.hostname + ':8000/ws/chat/' + roomName + '/'
        );

        chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            const chatLog = document.querySelector('#chat-log');
            const sender = data.sender || 'Unknown';

            if (sender !== username) {
                chatLog.innerHTML += '<div class="received-message"><strong>(' + sender + '): </strong>' + data.message + '</div>';
                chatLog.scrollTop = chatLog.scrollHeight;
            }
        };

        chatSocket.onclose = function(e) {
            console.error('Chat socket closed unexpectedly');
        };

        document.querySelector('#chat-message-input').focus();
        document.querySelector('#chat-message-input').onkeyup = function(e) {
            if (e.keyCode === 13) {
                document.querySelector('#chat-message-submit').click();
            }
        };

        document.querySelector('#chat-message-submit').onclick = function(e) {
            e.preventDefault();
            const messageInputDom = document.querySelector('#chat-message-input');
            const message = messageInputDom.value;
            if (message.trim()) {
                const chatLog = document.querySelector('#chat-log');
                chatLog.innerHTML += '<div class="sent-message"><strong>(' + username + '): </strong>' + message + '</div>';
                chatLog.scrollTop = chatLog.scrollHeight;
                if (chatSocket.readyState === WebSocket.OPEN) {
                    chatSocket.send(JSON.stringify({
                        'message': message,
                        'sender': username
                    }));
                } else {
                    console.error('WebSocket is not open. Message not sent.');
                }
                messageInputDom.value = '';
            }
        };

        const chatToggleButton = document.getElementById('chat-toggle-button');
        const chatCloseButton = document.getElementById('chat-close-button');
        const chatContainer = document.getElementById('chat-container');

        chatToggleButton.onclick = function(e) {
            chatContainer.classList.add('active');
            chatToggleButton.style.display = 'none';
        };

        chatCloseButton.onclick = function(e) {
            chatContainer.classList.remove('active');
            chatToggleButton.style.display = 'block';
        };

        const questionLinks = document.querySelectorAll('.question-link');
        const questionItems = document.querySelectorAll('.question-item');
        let currentQuestionIndex = 0;

        questionLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const questionId = this.dataset.questionId;
                showQuestion(questionId);
            });
        });

        document.getElementById('prev-button').addEventListener('click', function() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                showQuestionByIndex(currentQuestionIndex);
            }
        });

        document.getElementById('next-button').addEventListener('click', function() {
            if (currentQuestionIndex < questionItems.length - 1) {
                currentQuestionIndex++;
                showQuestionByIndex(currentQuestionIndex);
            }
        });

        document.getElementById('clear-button').addEventListener('click', function() {
            const currentQuestion = questionItems[currentQuestionIndex];
            const radioInputs = currentQuestion.querySelectorAll('input[type="radio"]');
            radioInputs.forEach(input => {
                input.checked = false;
            });
            checkAllAnswered();
            storeAnswers(); // Clear stored answers
        });

        function showQuestion(questionId) {
            questionItems.forEach(item => {
                item.classList.remove('active');
                if (item.id === questionId) {
                    item.classList.add('active');
                    currentQuestionIndex = Array.from(questionItems).indexOf(item);
                }
            });
            updateNavigationButtons();
        }

        function showQuestionByIndex(index) {
            questionItems.forEach(item => {
                item.classList.remove('active');
            });
            questionItems[index].classList.add('active');
            updateNavigationButtons();
        }

        function updateNavigationButtons() {
            const prevButton = document.getElementById('prev-button');
            const nextButton = document.getElementById('next-button');

            prevButton.disabled = currentQuestionIndex === 0;
            nextButton.disabled = currentQuestionIndex === questionItems.length - 1;
        }

        const submitButton = document.querySelector('.submit-button');
        const radioInputs = document.querySelectorAll('input[type="radio"]');

        function checkAllAnswered() {
            const answeredQuestions = new Set();
            radioInputs.forEach(input => {
                if (input.checked) {
                    answeredQuestions.add(input.name);
                }
            });
            if (answeredQuestions.size === questionItems.length) {
                submitButton.disabled = false;
            } else {
                submitButton.disabled = true;
            }
        }

        radioInputs.forEach(input => {
            input.addEventListener('change', function() {
                storeAnswers(); // Store answers on change
                checkAllAnswered();
            });
        });

        function storeAnswers() {
            const answers = {};
            radioInputs.forEach(input => {
                if (input.checked) {
                    answers[input.name] = input.value;
                }
            });
            sessionStorage.setItem('examAnswers', JSON.stringify(answers));
        }

        function restoreAnswers() {
            const storedAnswers = sessionStorage.getItem('examAnswers');
            if (storedAnswers) {
                const answers = JSON.parse(storedAnswers);
                Object.keys(answers).forEach(name => {
                    const input = document.querySelector(`input[name="${name}"][value="${answers[name]}"]`);
                    if (input) {
                        input.checked = true;
                    }
                });
            }
            checkAllAnswered(); 
        }

        restoreAnswers(); 

        const is_Proctor = {{ is_proctor|yesno:"true,false" }};

if (is_Proctor) {
    const closeExamButton = document.getElementById('close-exam-button');
    closeExamButton.addEventListener('click', function() {
        if (confirm('Are you sure you want to close the exam?')) {
            alert('The exam has been closed by the proctor.');
            window.location.href = '{% url "test_end" exam.id %}';
        }
    });

    // Listen for messages from WebSocket to close the exam for students
    const chatSocket = new WebSocket(
        'ws://' + window.location.hostname + ':8000/ws/chat/' + roomName + '/'
    );

    chatSocket.onmessage = function(e) {
        const data = JSON.parse(e.data);
        if (data.type === 'close_exam') {
            alert('The exam has been closed by the proctor.');
            window.location.reload(); // Reloads the page to reflect exam closure
        }
    };

    chatSocket.onclose = function(e) {
        console.error('Chat socket closed unexpectedly');
    };
}


        const examDuration = {{ exam.duration }};
        let duration = examDuration * 60;
        let startTime = sessionStorage.getItem('examStartTime');
        let elapsedTime = 0;

        if (startTime === null || sessionStorage.getItem('examStarted') === null) {
            startTime = new Date().getTime();
            sessionStorage.setItem('examStartTime', startTime);
            sessionStorage.setItem('examStarted', 'true');
        } else {
            startTime = parseInt(startTime);
            elapsedTime = Math.floor((new Date().getTime() - startTime) / 1000);
        }

        // Calculate time left based on elapsed time
        let timeLeft = duration - elapsedTime;

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;

            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimer() {
            timeLeft--;
            if (timeLeft >= 0) {
                document.getElementById('timer').textContent = formatTime(timeLeft);
                sessionStorage.setItem('examStartTime', startTime);
                setTimeout(updateTimer, 1000);
            } else {
                window.location.href = '{% url "test_end" exam.id %}';
            }
        }

        updateTimer();
        const constraints = {
    video: true,
    audio: true
};
const signalingSocket = new WebSocket(
    'ws://' + window.location.hostname + ':8000/ws/signaling/' + roomName + '/'
);
let pc;

signalingSocket.onmessage = function(event) {
    try {
        var message = JSON.parse(event.data);
        if (message.type === 'offer') {
            var sdp = message.sdp;
            console.log("Received SDP offer:", sdp);

            // Assume pc is your RTCPeerConnection object
            pc.setRemoteDescription(new RTCSessionDescription(sdp))
              .then(function() {
                  console.log("Remote description successfully set.");
                  // Proceed with ICE candidates or other steps
              })
              .catch(function(error) {
                  console.error("Error setting remote description:", error);
              });
        } else if (message.type === 'candidate') {
            var candidate = message.candidate;
            console.log("Received ICE candidate:", candidate);

            // Assume pc is your RTCPeerConnection object
            pc.addIceCandidate(new RTCIceCandidate(candidate))
              .then(function() {
                  console.log("ICE candidate added successfully.");
              })
              .catch(function(error) {
                  console.error("Error adding ICE candidate:", error);
              });
        }
    } catch (error) {
        console.error("Error parsing JSON:", error);
    }
};

signalingSocket.onclose = function(e) {
    console.error('Signaling socket closed unexpectedly');
};

async function startCall() {
    pc = new RTCPeerConnection();

    pc.onicecandidate = function(event) {
        if (event.candidate && signalingSocket.readyState === WebSocket.OPEN) {
            signalingSocket.send(JSON.stringify({
                type: 'candidate',
                candidate: event.candidate
            }));
        }
    };

    if (is_Proctor) {
        pc.ontrack = function(event) {
            const video = document.getElementById('student-video');
            video.srcObject = event.streams[0];
        };
    }

    try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        stream.getTracks().forEach(track => pc.addTrack(track, stream));

        if (!is_Proctor) {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            signalingSocket.send(JSON.stringify({
                type: 'offer',
                sdp: pc.localDescription
            }));
        }
    } catch (error) {
        console.error('Error starting call:', error);
    }
}

const isProctor = {{ is_proctor|yesno:"true,false" }};

if (!isProctor) {
    // Tab/Window change detection for students only
    let blurTimeout;

    window.addEventListener('blur', function() {
        blurTimeout = setTimeout(() => {
            sendTabChangeMessage();
        }, 1000);
    });

    window.addEventListener('focus', function() {
        clearTimeout(blurTimeout);
    });

    function sendTabChangeMessage() {
        if (chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify({
                'message': 'Student has changed the tab or window.',
                'sender': username
            }));
        }
    }
}

startCall();

    </script>
</body>
</html>